<!DOCTYPE html><head>
<title>Snake Invaders</title>
<meta charset="utf-8">
</head><body style="background:#000">
<script src="./littlejs.js"></script>
<script>
'use strict';

// engine settings, do not remove
debugWatermark = false;
showEngineVersion = false;
paused = false;

// engine settings
gravity = vec2(0, 0);
cameraPos = vec2(0, 0);
cameraScale = 26;

class SoundGenerator extends Sound 
{
    constructor(params = {})
    {
        const {
            volume = 1,
            randomness = .05,
            frequency = 220,
            attack = 0,
            release = .1,
            shapeCurve = 1,
            slide = 0,
            pitchJump = 0,
            pitchJumpTime = 0,
            repeatTime = 0,
            noise = 0,
            bitCrush = 0,
            delay = 0,
        } = params;
        
        super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0, pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
    }
}

///////////////////////////////////////////////////////////////////////////////
// Invaders Game Variables

const gridSize = vec2(28, 28);
let snake;
let direction;
let nextDirection;
let spiders = [];
let scorpions = [];
let scorpionWarnings = [];
let moveTimer;
let invaderMoveTimer;
let bulletMoveTimer;
let spiderSpawnTimer;
let scorpionSpawnTimer;
let moveDelay = .12;
let invaderMoveDelay = .4;
let bulletMoveDelay = .15;
let score;
let gameOver;

let eatSound;
let dieSound;
let hitSound;

///////////////////////////////////////////////////////////////////////////////
function resetGame()
{
    snake = [vec2(10,10), vec2(9,10), vec2(8,10)];
    direction = vec2(1,0);
    nextDirection = direction.copy();
    score = 0;
    gameOver = false;
    spiders = [];
    scorpions = [];
    scorpionWarnings = [];
    moveTimer = new Timer(moveDelay);
    invaderMoveTimer = new Timer(invaderMoveDelay);
    bulletMoveTimer = new Timer(bulletMoveDelay);
    spiderSpawnTimer = new Timer(2);
    scorpionSpawnTimer = new Timer(3);
}

function spawnSpider()
{
    const fromTop = rand() < 0.5;
    const y = fromTop ? gridSize.y - 1 : 0;
    const dir = fromTop ? vec2(0, -1) : vec2(0, 1);
    const x = randInt(gridSize.x);
    let p = vec2(x, y);
    let linesBusy = 0;
    while (!lineIsClear(p.x)) // ensure spider doesn't spawn in a column with a snake segment or scorpion
    {
        p.x = (p.x + 1) % gridSize.x; // move right and wrap around
        linesBusy++;
        if (linesBusy >= gridSize.x) { // if all lines are busy, give up
            return;
        }
    }

    // Check if position is clear
    if (!spiders.find(i => i.pos.x == p.x && i.pos.y == p.y) && 
        !snake.find(s => s.x == p.x && s.y == p.y))
    {
        spiders.push({pos: p, dir: dir});
    }
}

function spawnScorpion()
{
    const x = randInt(gridSize.x - 1); // -1 to account for 2x2 size
    const p = vec2(x, gridSize.y - 1); // -1 to spawn with bottom 2 rows visible
    // Check if all 4 positions are clear for 2x2 scorpion
    const positions = [p, vec2(p.x+1, p.y), vec2(p.x, p.y+1), vec2(p.x+1, p.y+1)];
    const allClear = positions.every(pos => 
        !scorpions.find(b => {
            const bPos = [b.pos, vec2(b.pos.x+1, b.pos.y), vec2(b.pos.x, b.pos.y+1), vec2(b.pos.x+1, b.pos.y+1)];
            return bPos.some(bp => bp.x == pos.x && bp.y == pos.y);
        }) &&
        !spiders.find(i => i.pos.x == pos.x && i.pos.y == pos.y) &&
        !snake.find(s => s.x == pos.x && s.y == pos.y)
    );
    if (allClear)
    {
        scorpions.push({pos: p, dir: vec2(0, -1)});
    }
}

///////////////////////////////////////////////////////////////////////////////
async function gameInit()
{
    setCanvasFixedSize(vec2(720,720));
    cameraPos = gridSize.scale(.5);
    
    eatSound = new SoundGenerator({frequency:600, release:.05});
    dieSound = new SoundGenerator({frequency:120, release:.3, slide:-.2});
    hitSound = new SoundGenerator({frequency:200, release:.15, noise:.1});
    
    resetGame();
}

let tickNumber = 0;
let nextTurnSpawnScorpion = false;
let lastScorptionPosition = null;
///////////////////////////////////////////////////////////////////////////////
function gameUpdate() {
    if (gameOver) {
        if (keyWasPressed('Space'))
            resetGame();
        return;
    }

    // input
    const inputDir = keyDirection();
    if (inputDir.lengthSquared()) {
        // prevent reversing
        if (!inputDir.add(direction).lengthSquared() == 0)
            nextDirection = inputDir;
    }

    // spawn spiders
    if (spiderSpawnTimer.elapsed())
    {
        spiderSpawnTimer.set(rand(1.5, 3));
        spawnSpider();
    }

    // spawn scorpion warnings
    if (scorpionSpawnTimer.elapsed())
    {
        scorpionSpawnTimer.set(rand(3, 5));
        // Find a valid position for scorpion
        let x = randInt(gridSize.x - 1);
        // cant be too close of lastScorptionPosition
        if (x == lastScorptionPosition?.x || x == lastScorptionPosition?.x - 1 || x == lastScorptionPosition?.x + 1)
        {
            x += x < gridSize.x / 2 ? 2 : -2;
        }
        // Randomly choose to spawn from top or bottom
        const fromTop = rand() < 0.5;
        const y = fromTop ? gridSize.y - 1 : 0;
        const dir = fromTop ? vec2(0, -1) : vec2(0, 1);
        let p = vec2(x, y);

        const positions = [p, vec2(p.x+1, p.y), vec2(p.x, p.y+1), vec2(p.x+1, p.y+1)];
        // const allClear = positions.every(pos => 
        //     !scorpions.find(b => {
        //         const bPos = [b.pos, vec2(b.pos.x+1, b.pos.y), vec2(b.pos.x, b.pos.y+1), vec2(b.pos.x+1, b.pos.y+1)];
        //         return bPos.some(bp => bp.x == pos.x && bp.y == pos.y);
        //     }) &&
        //     !spiders.find(i => i.pos.x == pos.x && i.pos.y == pos.y) &&
        //     !snake.find(s => s.x == pos.x && s.y == pos.y)
        // );
        // if (allClear)
        // {
        // }
        scorpionWarnings.push({pos: p, countdown: 10, dir: dir});
        lastScorptionPosition = p;
    }


    if (moveTimer.elapsed())
    {
        justAte = false;
        tickNumber++;
        
        // Update scorpion warnings and spawn when ready
        for (let i = scorpionWarnings.length - 1; i >= 0; i--) {
            scorpionWarnings[i].countdown--;
            if (scorpionWarnings[i].countdown <= 0)
            {
                const p = scorpionWarnings[i].pos;
                const dir = scorpionWarnings[i].dir;
                scorpions.push({pos: p, dir: dir});
                scorpionWarnings.splice(i, 1);
            }
        }

        // move scorpions every 2 turns 
        if (tickNumber % 2 === 0) { 
            for (let i = scorpions.length - 1; i >= 0; i--)
            {
                scorpions[i].pos = scorpions[i].pos.add(scorpions[i].dir);
                // Remove when off screen (check both directions)
                if (scorpions[i].pos.y < -1 || scorpions[i].pos.y >= gridSize.y || scorpions[i].pos.x < 0 || scorpions[i].pos.x + 1 >= gridSize.x)
                    scorpions.splice(i, 1);
            }
        }

        if (tickNumber % 3 === 0) { // move spiders every 3 turns 
            for (let i = spiders.length - 1; i >= 0; i--) {
                // only move the spider if the next position is clear (don't move onto snake or other spider)
                if (positionIsClear(spiders[i].pos.add(spiders[i].dir))) {
                    spiders[i].pos = spiders[i].pos.add(spiders[i].dir);
                }

                // Remove if off screen
                if (spiders[i].pos.y < 0 || spiders[i].pos.y >= gridSize.y || spiders[i].pos.x < 0 || spiders[i].pos.x >= gridSize.x)
                    spiders.splice(i, 1);
            }
        }
        moveTimer.set(moveDelay);
        direction = nextDirection.copy();
        updateSnake();
    }
}
let justAte = false;

function positionIsClear(pos) {
    return !snake.find(s => s.x == pos.x && s.y == pos.y) &&
           !spiders.find(i => i.pos.x == pos.x && i.pos.y == pos.y) &&
           !scorpions.find(b => {
               const bPositions = [b.pos, vec2(b.pos.x+1, b.pos.y), vec2(b.pos.x, b.pos.y+1), vec2(b.pos.x+1, b.pos.y+1)];
               return bPositions.some(bp => bp.x == pos.x && bp.y == pos.y);
           });
}

function lineIsClear(x) {
    return !snake.find(s => s.x == x) &&
           !spiders.find(i => i.pos.x == x) &&
           !scorpions.find(b => {
               const bPositions = [b.pos, vec2(b.pos.x+1, b.pos.y), vec2(b.pos.x, b.pos.y+1), vec2(b.pos.x+1, b.pos.y+1)];
               return bPositions.some(bp => bp.x == x);
           });
}


function updateSnake()
{
    const prevHead = snake[0];
    const head = snake[0].add(direction);

    // wall collision
    if (head.x < 0 || head.y < 0 || head.x >= gridSize.x || head.y >= gridSize.y)
    {
        die();
        return;
    }

    // self collision
    if (snake.find(s => s.x == head.x && s.y == head.y))
    {
        die();
        return;
    }

    snake.unshift(head);

    // check if eating spider
    const invaderIndex = spiders.findIndex(i => 
        // if snake move towards spider
        i.pos.x == head.x && i.pos.y == head.y 
        // if spider moved onto snake head and was goin the opposite direction of the snake
        || (prevHead.x == i.pos.x && prevHead.y == i.pos.y && direction.x == -i.dir.x && direction.y == -i.dir.y) 
    );
    if (invaderIndex !== -1)
    {
        score++;
        eatSound.play();
        spiders.splice(invaderIndex, 1);
        // snake grows (don't pop tail)
        justAte = true;
    }
    else
    {
        snake.pop();
    }

    // check if any scorpion hits any part of snake (check all 4 positions of 2x2 scorpion)
    for (let i = scorpions.length - 1; i >= 0; i--)
    {
        const bulletPositions = [
            scorpions[i].pos,
            vec2(scorpions[i].pos.x + 1, scorpions[i].pos.y),
            vec2(scorpions[i].pos.x, scorpions[i].pos.y + 1),
            vec2(scorpions[i].pos.x + 1, scorpions[i].pos.y + 1)
        ];
        
        let snakeIndex = -1;
        for (let bPos of bulletPositions) {
            const idx = snake.findIndex(s => s.x == bPos.x && s.y == bPos.y);
            if (idx !== -1) {
                snakeIndex = idx;
                break;
            }
        }
        
        // Check if scorpion moved onto head from opposite direction
        for (let bPos of bulletPositions) {
            if ((prevHead.x == bPos.x && prevHead.y == bPos.y) &&
                direction.x == -scorpions[i].dir.x && direction.y == -scorpions[i].dir.y) {
                snakeIndex = 0;
                break;
            }
        }

        if (snakeIndex !== -1)
        {
            hitSound.play();
            // scorpions.splice(i, 1);
            
            // if head is hit game over
            if (snakeIndex === 0)
            {
                die();
                return;
            }
            
            // remove the snake segment that was hit and everything after it (the tail is more likely to be hit and it's less punishing to lose length than to lose the head)
            snake.splice(snakeIndex);
            break;
            
        }
    }

    // check if any spider hits the snake (non-head)
    // for (let i = spiders.length - 1; i >= 0; i--)
    // {
    //     const snakeIndex = snake.findIndex(s => s.x == spiders[i].pos.x && s.y == spiders[i].pos.y);
    //     if (snakeIndex > 0)
    //     {
    //         hitSound.play();
    //         // spiders.splice(i, 1);
    //         // remove the snake segment that was hit and everything after it
    //         snake.splice(snakeIndex);
    //         break;
    //     }
    // }
}

function die()
{
    gameOver = true;
    dieSound.play();
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdatePost() {}

///////////////////////////////////////////////////////////////////////////////
function gameRender()
{
    // drawRect(cameraPos, gridSize, hsl(0,0,.05));
    // background
    const tileWidth = 16;
    const rows = 30 / 0.57;
    const cols = 30 / 0.57;
    for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
            drawTile(vec2(i * 0.57, j * 0.57), vec2(0.57), tile(0, vec2(16, 16), 4));
        }
    }
    // drawTile(cameraPos, gridSize, tile(0, vec2(1000, 1000), 4));
    const frame = (time*2)%2|0;

    // scorpion warnings
    for (let warning of scorpionWarnings)
    {
        if (warning.countdown > 5) {
            drawTile(
                warning.pos.add(warning.dir.scale(1)).add(vec2(1, 0)),
                vec2(1.2),
                tile(0, vec2(64, 64), 3)
            );
        }
    }

    // spiders (draw as space spider shaped squares)
    for (let spider of spiders)
    {
        // drawRect(spider.pos.add(vec2(.5)), vec2(1), hsl(.55,1,.5)); // cyan
        const pos = spider.pos.add(vec2(.5));
        // console.log(pos, frame);
        drawTile(pos, vec2(1), tile(0, vec2(42, 42), 0).frame(frame));
    }

    for (let i=1; i<snake.length; i++)
    {
        let angle = 0;
        let tilePos = vec2(0,4);
        // if right to left or left to right rotate it 90 degrees to better fit the line connection
        if ((snake[i].y == snake[i-1].y) && (i === snake.length - 1 || snake[i].y == snake[i+1].y)) {
            angle = 90 * (Math.PI / 180);
        }
        const newTile = tile(tilePos.y * 4 + tilePos.x, vec2(32, 32), 1);
        drawTile(snake[i].add(vec2(.5)), vec2(1), newTile, undefined, angle);
    }


    // draw lines between snake segments
    for (let i = 0; i < snake.length - 1; i++)
    {
        let start = snake[i].add(vec2(.5));
        let end = snake[i+1].add(vec2(.5));
        // if its top to bottom or bottom to top move it slighly to the left:
        if (snake[i].x == snake[i+1].x) 
        {
            start = start.add(vec2(-.1, 0));
            end = end.add(vec2(-.1, 0));
        }
        drawLine(start, end, .3, hsl(.147, 1, .55));
    }

    /*
    snake spritesheet is
    [
        [bottom_right, bottom_right_eating, bottom_left, bottom_left_eating],
        [bottom, bottom_eating, top, top_eating],
        [right, right_eating, left, left_eating],
        [top_right, top_right_eating, top_left, top_left_eating],
        [body]
    ]
    */
    let headPos;
    // bottom_right
    if (direction.x == 1 && direction.y == -1) headPos = vec2(0,0);
    // bottom_left
    else if (direction.x == -1 && direction.y == -1) headPos = vec2(2,0);
    // bottom
    else if (direction.x == 0 && direction.y == -1) headPos = vec2(0,1);
    // top
    else if (direction.x == 0 && direction.y == 1) headPos = vec2(2,1);
    // right
    else if (direction.x == 1 && direction.y == 0) headPos = vec2(0,2);
    // left
    else if (direction.x == -1 && direction.y == 0) headPos = vec2(2,2);
    // top_right
    else if (direction.x == 1 && direction.y == 1) headPos = vec2(0,3);
    // top_left
    else if (direction.x == -1 && direction.y == 1) headPos = vec2(2,3);
    
    const headTile = tile(headPos.y * 4 + headPos.x, vec2(32, 32), 1);
    drawTile(snake[0].add(vec2(.5)), vec2(1), headTile.frame(justAte ? 1 : 0));

    

    // scorpions (red projectiles) - 2x2 grid
    for (let scorpion of scorpions)
    {
        // Draw all 4 squares of the 2x2 scorpion
        drawTile(
            scorpion.pos.add(vec2(1)),
            vec2(1.5, 3),
            tile(0, vec2(64, 122), 2).frame(frame),
            WHITE,
            scorpion.dir.y > 0 ? 180 * (Math.PI / 180) : 0,
        );
        console.log(scorpion.pos, scorpion.dir.y > 0);
        // drawRect(scorpion.pos.add(vec2(.5)), vec2(.9), RED);
        // drawRect(scorpion.pos.add(vec2(1.5, .5)), vec2(.9), RED);
        // drawRect(scorpion.pos.add(vec2(.5, 1.5)), vec2(.9), RED);
        // drawRect(scorpion.pos.add(vec2(1.5, 1.5)), vec2(.9), RED);
    }

    // foreground
    // drawTile(cameraPos, gridSize, tile(0, vec2(1000, 1000), 5));

}

///////////////////////////////////////////////////////////////////////////////
function gameRenderPost()
{
    drawTextScreen(`Score: ${score}  Length: ${snake.length}`, vec2(mainCanvasSize.x/2, 40), 40, WHITE, 4, BLACK);

    if (gameOver)
    {
        drawTextScreen(`Game Over`, vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 - 40), 60, RED, 6, BLACK);
        drawTextScreen(`Press Space to Restart`, vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 + 20), 40, WHITE, 4, BLACK);
    }
}

///////////////////////////////////////////////////////////////////////////////
engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost, 
['spider_42x42.png', 'snake_32x32.png', 'scorpion_64x122.png', 'warning_64x64.png', 'background_tile_16x16.png']);

</script>
